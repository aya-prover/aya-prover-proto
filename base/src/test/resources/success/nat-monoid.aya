prim I
prim left
prim right
struct Path (A : I -> Type) (a : A left) (b : A right) : Type
 | at (i : I) : A i {
   | left => a
   | right => b
 }
def path {A : I -> Type} (p : Pi (i : I) -> A i)
  => new Path A (p left) (p right) { | at i => p i }
def `=` Eq {A : Type} (a b : A) : Type => Path (\ i => A) a b
def idp {A : Type} (a : A) : a = a => path (\ i => a)

def pmap {A B : Type} (f : A -> B) {a b : A} (p : a = b)
  : f a = f b => path (\ i => f (p.at i))

bind = looser application

open data Nat : Type
 | zero
 | suc Nat

struct Monoid { A : Type } ( op : A -> A -> A ) ( id : A ) : Type
  | assoc (a b c : A) : op (op a b) c = op a (op b c)
  | id_r (a: A) : op a id = a
  | id_l (a: A) : op id a = a

def `+` addN ( a b : Nat ) : Nat
 | zero, a => a
 | a, zero => a
 | suc a, b => suc (a + b)
 | a, suc b => suc (a + b)

bind + tighter =

def +-id_r ( a : Nat ) : a + zero = a => idp a
def +-id_l ( a : Nat ) : zero + a = a => idp a

def +-assoc ( a b c : Nat ) : (a + b) + c = a + (b + c)
  | zero  , b , c => idp (b + c)
  | suc a , b , c => pmap suc (+-assoc a b c)

def +-monoid => new Monoid addN zero {
  | assoc a b c => +-assoc a b c
  | id_r a => +-id_r a
  | id_l a => +-id_l a
}
